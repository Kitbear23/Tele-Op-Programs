#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C1_1,     LeftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     RightMotor,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     GripperMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     LifterMotor,   tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Servo,  srvo_S1_C3_1,    LifterServo,          tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    GripperServo,         tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    GoalServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    HookServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                           Tele-Operation Mode Code Template
//
// This file contains a template for simplified creation of an tele-op program for an FTC
// competition.
//
// You need to customize two functions with code unique to your specific robot.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


#define CONV_FACT_NUM_Q2        39 //(9.75 * 2^2)
#define CONV_FACT_DEN          128
#define JOYSTICK_DEADBAND        3
#define FOURTH_MTR_DEADBAND     10
#define MODE_FORWARD             0
#define MODE_REVERSED            1
#define X_SQRD_MTR_PWR           0
#define LNR_FOURTH_MTR_PWR       1
#define LNR_FULL_MTR_PWR         2

int BaseMotorPowerPreviousUpdate_L;
int BaseMotorPowerPreviousUpdate_R;
int Joystick_L;
int Joystick_R;
bool RedBtn;
bool Joy1Btn3_Previous;
int JoystickMode;
int BaseMode;
int LifterEncoderCounts;
int MotorPower_L;
int MotorPower_R;

void JoystickConfiguration();
void BaseRun();
int ConvertJoystickToMotorPower(int Joystick);

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of tele-op mode, you may want to perform some initialization on your robot
// and the variables within your program.
//
// In most cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

void initializeRobot()
{
	nMotorEncoder(LifterMotor) = 0;
	servo(LifterServo) = 0; //Starting Value
	RedBtn = false;
	Joy1Btn3_Previous = false;
	servo(GoalServo) = 90;
	servo(GripperServo) = 145;
	servo(HookServo) = 0;
	motor[LeftMotor] = 0;
	motor[RightMotor] = 0;
	JoystickMode = MODE_FORWARD;
	BaseMode = LNR_FULL_MTR_PWR;

	return;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the tele-op robot operation. Customize as appropriate for
// your specific robot.
//
// Game controller / joystick information is sent periodically (about every 50 milliseconds) from
// the FMS (Field Management System) to the robot. Most tele-op programs will follow the following
// logic:
//   1. Loop forever repeating the following actions:
//   2. Get the latest game controller / joystick settings that have been received from the PC.
//   3. Perform appropriate actions based on the joystick + buttons settings. This is usually a
//      simple action:
//      *  Joystick values are usually directly translated into power levels for a motor or
//         position of a servo.
//      *  Buttons are usually used to start/stop a motor or cause a servo to move to a specific
//         position.
//   4. Repeat the loop.
//
// Your program needs to continuously loop because you need to continuously respond to changes in
// the game controller settings.
//
// At the end of the tele-op period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

task main()
{
	initializeRobot();

	waitForStart();   // wait for start of tele-op phase

	while(true)
	{
		//////////
		// Hook //
		//////////
		if(servo[HookServo] == 90)
		{
			if(joystick.joy1_TopHat == 4)
			{
				servo[HookServo] = 240;
				wait1Msec(500);
			}
		}
		else if(servo[HookServo] == 240)
		{
			if(joystick.joy1_TopHat == 4)
			{
				servo[HookServo] = 90;
				wait1Msec(500);
			}
		}
		///////////
		//Grabber//
		///////////
		if(servo[GoalServo] == 90)
		{
			if(joy1Btn(4) == true)
			{
				servo[GoalServo] = 240;
				wait1Msec(500);
			}
		}
		else if(servo[GoalServo] == 240)
		{
			if(joy1Btn(4) == true)
			{
				servo[GoalServo] = 90;
				wait1Msec(500);
			}
		}
		///////////////////////
		//       Gripper     //
		///////////////////////
		if(joy1Btn(5) == true)
		{
			motor(GripperMotor) = 100;
		}
		else if(joy1Btn(5) == false)
		{
			motor(GripperMotor) = 0;
		}

		if(servo[GripperServo] == 0)
		{
			if(joy1Btn(7) == true)
			{
				servo[GripperServo] = 145;
				wait1Msec(500);
			}
			else
			{
			}
		}
		else if(servo[GripperServo] == 145)
		{
			if(joy1Btn(7) == true)
			{
				servo[GripperServo] = 0;
				wait1Msec(500);
			}
			else
			{
			}
		}
		///////////////////////
		//       Lifter      //
		///////////////////////
		LifterEncoderCounts = nMotorEncoder(LifterMotor);

		if(joy1Btn(6) == true && LifterEncoderCounts <= 6600)
		{
			motor(LifterMotor) = 100;
		}
		else if (joy1Btn(8) == true && LifterEncoderCounts >= 100)
		{
			motor(LifterMotor) = -10;
		}
		else
		{
			motor(LifterMotor) = 6;
		}

		if(joy1Btn(1) == true)
		{
			servo(LifterServo) = 0;
		}

		if(joy1Btn(2) == true && servo(LifterServo) <= 215)
		{
			servo(LifterServo) = servo(LifterServo) + 10;
			wait1Msec(20);
		}
		///////////////////////
		//       Base        //
		///////////////////////
		JoystickConfiguration();

		BaseRun();

		wait1Msec(50);
	}
}

int ConvertJoystickToMotorPower(int Joystick)
{
	int MotorPower;

	if(BaseMode == LNR_FOURTH_MTR_PWR)
	{
		MotorPower = Joystick/4;
	}
	else if(BaseMode == LNR_FULL_MTR_PWR)
	{
		MotorPower = Joystick;
	}
	else //BaseMode == X_SQRD_MTR_PWR
	{
		MotorPower = Joystick * CONV_FACT_NUM_Q2 / CONV_FACT_DEN;
		MotorPower = (MotorPower*MotorPower) >>4;
		if(Joystick < 0)
		{
			MotorPower = -MotorPower - 5;
		}
		else
		{
			MotorPower = MotorPower + 5;
		}
	}

	return MotorPower;
}

void JoystickConfiguration()
{
	//bool Button_Previous = false;
	if(joy1Btn(3) == true && Joy1Btn3_Previous == false)
	{
		RedBtn = true;
		Joy1Btn3_Previous = true;
	}
	else if(joy1Btn(3) == true && Joy1Btn3_Previous == true)
	{
		//do nothing
	}
	else
	{
		Joy1Btn3_Previous = false;
	}

	if(RedBtn == true && BaseMode == LNR_FULL_MTR_PWR)
	{
		BaseMode = LNR_FOURTH_MTR_PWR;
		RedBtn = false;
	}
	else if(RedBtn == true && BaseMode == LNR_FOURTH_MTR_PWR)
	{
		BaseMode = LNR_FULL_MTR_PWR;
		RedBtn = false;
	}

	if(JoystickMode == MODE_FORWARD)
	{
		Joystick_L = joystick.joy1_y1;
		Joystick_R = joystick.joy1_y2;
	}
}

void BaseRun()
{
	if(abs(Joystick_L) < JOYSTICK_DEADBAND)
	{
		MotorPower_L = 0;
	}
	else
	{
		if(BaseMode == LNR_FOURTH_MTR_PWR && abs(Joystick_L) < 40)
		{
			if(Joystick_L < 0)
			{
				MotorPower_L = ConvertJoystickToMotorPower(Joystick_L) - FOURTH_MTR_DEADBAND;
			}
			else
			{
				MotorPower_L = ConvertJoystickToMotorPower(Joystick_L) + FOURTH_MTR_DEADBAND;
			}
		}
		else
		{
			MotorPower_L = ConvertJoystickToMotorPower(Joystick_L);
		}
	}

	if(abs(Joystick_R) < JOYSTICK_DEADBAND)
	{
		MotorPower_R = 0;
	}
	else
	{
		if(BaseMode == LNR_FOURTH_MTR_PWR && abs(Joystick_R) < 40)
		{
			if(Joystick_R < 0)
			{
				MotorPower_R = ConvertJoystickToMotorPower(Joystick_R) - FOURTH_MTR_DEADBAND;
			}
			else
			{
				MotorPower_R = ConvertJoystickToMotorPower(Joystick_R) + FOURTH_MTR_DEADBAND;
			}
		}
		else
		{
			MotorPower_R = ConvertJoystickToMotorPower(Joystick_R);
		}
	}

	motor[LeftMotor] = MotorPower_L;
	motor[RightMotor] = MotorPower_R;

	BaseMotorPowerPreviousUpdate_L = MotorPower_L;
	BaseMotorPowerPreviousUpdate_R = MotorPower_R;
}
